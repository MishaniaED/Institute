#!/usr/bin/env python
# coding: utf-8

# In[1]:


# Описание алгоритма 


# Необходимые определения: 
# -Паросочетанием M называется набор попарно несмежных рёбер графа (иными словами, любой вершине графа должно быть инцидентно не более одного ребра из множества M).
# Мощностью паросочетания назовём количество рёбер в нём. Наибольшим (или максимальным) паросочетанием назовём паросочетание, мощность которого максимальна среди всех возможных паросочетаний в данном графе.
# Все те вершины, у которых есть смежное ребро из паросочетания (т.е. которые имеют степень ровно один в подграфе, образованном M), назовём насыщенными этим паросочетанием.

# -Цепью длины  назовём некоторый простой путь (т.е. не содержащий повторяющихся вершин или рёбер), содержащий  рёбер.

# -Чередующейся цепью (в двудольном графе, относительно некоторого паросочетания) назовём цепь, в которой рёбра поочередно принадлежат/не принадлежат паросочетанию.

# -Увеличивающей цепью (в двудольном графе, относительно некоторого паросочетания) назовём чередующуюся цепь, у которой начальная и конечная вершины не принадлежат паросочетанию.


# Теорема Бержа: 
# Паросочетание является максимальным тогда и только тогда, когда не существует увеличивающих относительно него цепей.


# In[ ]:


# Алгоритм Куна: 
# Алгоритм Куна — непосредственное применение теоремы Бержа.
# Его можно кратко описать так: сначала возьмём пустое паросочетание, а потом — пока в графе удаётся найти увеличивающую цепь, — будем выполнять чередование паросочетания вдоль этой цепи, и повторять процесс поиска увеличивающей цепи.
# Как только такую цепь найти не удалось — процесс останавливаем, — текущее паросочетание и есть максимальное.

# Осталось детализировать способ нахождения увеличивающих цепей. Алгоритм Куна — просто ищет любую из таких цепей с помощью обхода в глубину или в ширину. 
# Алгоритм Куна просматривает все вершины графа по очереди, запуская из каждой обход, пытающийся найти увеличивающую цепь, начинающуюся в этой вершине.

# Поиск увеличивающей цепи осуществляется с помощью специального обхода в глубину или ширину (обычно в целях простоты реализации используют именно обход в глубину).
# Изначально обход в глубину стоит в текущей ненасыщенной вершине  первой доли. Просматриваем все рёбра из этой вершины, пусть текущее ребро — это ребро .
# Если вершина  ещё не насыщена паросочетанием, то, значит, мы смогли найти увеличивающую цепь: она состоит из единственного ребра ; в таком случае просто включаем это ребро в паросочетание и прекращаем поиск увеличивающей цепи из вершины .
# Иначе, — если  уже насыщена каким-то ребром , то попытаемся пройти вдоль этого ребра: тем самым мы попробуем найти увеличивающую цепь, проходящую через рёбра , . Для этого просто перейдём в нашем обходе в вершину  — теперь мы уже пробуем найти увеличивающую цепь из этой вершины.
# Можно понять, что в результате этот обход, запущенный из вершины , либо найдёт увеличивающую цепь, и тем самым насытит вершину , либо же такой увеличивающей цепи не найдёт (и, следовательно, эта вершина  уже не сможет стать насыщенной).
# После того, как все вершины  будут просмотрены, текущее паросочетание будет максимальным.

# Время работы 
# Алгоритм Куна можно представить как серию из n запусков обхода в глубину/ширину на всём графе. Следовательно, всего этот алгоритм исполняется за время O(nm), что в худшем случае есть O(n^3).


# In[ ]:


# Реализация основанная на обходе в глубину, и принимающей двудольный граф в виде явно разбитого на две доли графа. 
# n  — число вершин в первой доле, k — во второй доле, graph[v]  — список рёбер из вершины v первой доли (т.е. список номеров вершин, в которые ведут эти рёбра из v). Вершины в обеих долях занумерованы независимо, т.е. первая доля — с номерами 1...n, вторая — с номерами 1...k.
# Дальше идут два вспомогательных массива: mt и used. Первый — mt[i] — содержит в себе информацию о текущем паросочетании. Для удобства программирования, информация эта содержится только для вершин второй доли: mt[i] — это номер вершины первой доли, связанной ребром с вершиной i второй доли (или -1, если никакого ребра паросочетания из i не выходит).
# Второй массив — used — обычный массив "посещённостей" вершин в обходе в глубину (он нужен, просто чтобы обход в глубину не заходил в одну вершину дважды).
# Функция try_kuhn — и есть обход в глубину. Она возвращает true, если ей удалось найти увеличивающую цепь из вершины v, при этом считается, что эта функция уже произвела чередование паросочетания вдоль найденной цепи.
# Внутри функции просматриваются все рёбра, исходящие из вершины v первой доли, и затем проверяется: если это ребро ведёт в ненасыщенную вершину t0, либо если эта вершина t0 насыщена, но удаётся найти увеличивающую цепь рекурсивным запуском из m[t0], то мы говорим, что мы нашли увеличивающую цепь, и перед возвратом из функции с результатом true производим чередование в текущем ребре: перенаправляем ребро, смежное с t0, в вершину v.
# В основной программе сначала указывается, что текущее паросочетание — пустое (список mt заполняется числами -1). Затем перебирается вершина v первой доли, и из неё запускается обход в глубину try_kuhn, предварительно обнулив массив used.
# Само искомое максимальное паросочетание содержится в массиве .


# In[1]:


import sys
mt = []
used = []
def try_kuhn(v):
    if (used[v]): # Если вершина является пройденной, то не производим из нее вызов процедуры
        return False 
    used[v] = True # помечаем вершину первой доли, как пройденную
    for i in range(len(graph[v])):
            to = graph[v][i]
            if (mt[to] == -1 or try_kuhn (mt[to])):
                mt[to] = v
                return True 
    return False 

with open(sys.argv[1], 'r') as f: # Считываем файл
    n = int(f.readline())
    k = int(f.readline(2))
    matrix = [list(map(int, row.split())) for row in f.readlines()]


graph = []
for i in range(n):
    graph.append([])
    for j in range(k):
        if matrix[i][j] != 0:
            graph[i].append(j)
            

for i in range(k):
    mt.append(-1)

for v in range(n):
    for j in range(n):
        used.append(False)
    try_kuhn(v)
    
with open(sys.argv[1], 'a') as f: # Дополняем файл
    f.write('Colors_Edges:\n')
    for i in range(k):
        if (mt[i] != -1):
            f.write(str(mt[i]) + ' ')
            f.write(str(i) + ' Black\n')
    f.write('Text:\n')
    for i in range(k):
        if (mt[i] != -1):
            f.write('<' + str(mt[i]) + ', ')
            f.write(str(i) + '>\n')
    